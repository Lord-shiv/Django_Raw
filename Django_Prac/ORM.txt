Q.1 Calculate the mean score of all users.
# Aggregate calculates values for the entire queryset
ans. CUser.objects.all().aggergate(Max(‘score’)

Q.2 Find the user with the highest score.
ans. CUser.objects.all().filter(score=2)

Q.3 Find if there is any user with score less than 2 (return True/False)
ans. CUser.objects.all().exclude(score__gte=2)

Q.4 Change the score value of all users in a single query to 100 (one hundred)?
ans. CUser.objects.all().update(score=100)

Q.5 Find all the users which don't have score 10 or 20
ans. CUser.objects.all().filter(~Q(user__score=10 | ~Q(user__score=20)

Q.6 Print a list of all the score values from all users excluding the first 10 users.
ans. CUser.objects.all().score[10:]

Q.7 Find all the users which have score exactly equal to the mean score (need to calculate mean score again in the same query).
ans. CUser.objects.all().filter(user.score ==aggergate(Avg(‘score’)))

Q.8 How to create multiple objects in one shot?
ans. Catergory.objects.bulk_create([catergory(name='God'), category(name='Demi God'), category(name='mortal')])

Q.9 How to filer FileField without any file?
ans. no_files_objects = MyModel.objects.filter(Q(file='') | Q(file=None))

Q.10 if you want to find blogs with more than 5 entries?
ans. from django.db.models import Count
     blogs = Blog.objects.alias(entries=Count('entry')).filter(entries__gt=5)

Q.11 How to check Foreginkey's instances ==> Django_Prac ++> app_mtm **> book, publisher
ans. pubs = Publisher.objects.annotate(num_books=Count('book'))
     pubs[0].num_books

Q.12 How to count authors form a book with MTM relation.
# Annotate calculates summary values for each item in the queryset
# alias saves the expression for later reuse with other QuerySet methods
ans. obj = Book.objects.annotate(Count('authors'))
     obj[0], obj[0] will return books
     obj[0].authors__count
     obj[1].authors__count


**Notes**
Returns a QuerySet that returns dictionaries, rather than model instances. return list and inside dict
This is similar to values() except that instead of returning dictionaries, it returns tuples when iterated over flat True return tuple for each element inside list
select_related() ==> Returns a QuerySet that will “follow” foreign-key relationships, selecting additional related-object data when it executes its query.
prefetch_related() ==> on the other hand, does a separate lookup for each relationship, and does the ‘joining’ in Python. This allows it to prefetch many-to-many and many-to-one objects, which cannot be done using select_related, in addition to the foreign key and one-to-one relationships that are supported by select_related. 
defer() & only() ==> defer() and only() are somewhat opposite of each other. Both receives list of field_names. defer() will not query, list of columns, passed to it as argument. On Contrary to it, only() will query, only list of columns, passed to it as argument.


# https://stackoverflow.com/questions/31457732/django-or-query-using-extra-and-filter
extra() ==> (select=None, where=None, params=None, tables=None, order_by=None, select_params=None) Sometimes, the Django query syntax by itself can’t easily express a complex WHERE clause. For these edge cases, Django provides the extra() QuerySet modifier — a hook for injecting specific clauses into the SQL generated by a QuerySet.
ORM :: Model.objects.filter(clauseA) | Model.objects.extra(clauseB)
SQL :: SELECT * FROM model WHERE clauseA OR clauseB.

@select@ argument lets you put extra fields in the SELECT clause. It should be a dictionary mapping attribute names to SQL clauses to use to calculate that attribute
ORM :: Entry.objects.extra(select={'is_recent': "pub_date > '2006-01-01'"})

@where@ You can define explicit SQL WHERE clauses — perhaps to perform non-explicit joins — by using where.
ORM :: Entry.objects.extra(where=["foo='a' OR bar = 'a'", "baz = 'a'"])

SQL :: SELECT * FROM blog_entry WHERE (foo='a' OR bar='a') AND (baz='a')
@params@  
ORM :: Entry.objects.extra(where=["foo='a' OR bar = 'a'", "baz = 'a'"])
SQL :: SELECT * FROM blog_entry WHERE (foo='a' OR bar='a') AND (baz='a')


using() ==> takes alias as parameter. Entry.objects.using('backup')
